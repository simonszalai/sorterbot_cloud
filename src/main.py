"""
Main module responsible for orchestrating image processing.

"""

import os
import traceback
from yaml import load, Loader, YAMLError
from pathlib import Path
from dotenv import load_dotenv

from locator.detectron import Detectron
from vectorizer.vectorizer import Vectorizer
from utils.postgres import Postgres
from utils.logger import logger
from utils.S3 import S3
from utils.coord_conversion import object_to_polar, filter_duplicates


class Main:
    """
    Main class for controlling image processing. When instantiated, it loads all neccessary environment
    variables and config files and instantiates all needed modules.

    Parameters
    ----------
    base_img_path : str
        Location where the downloaded images should be stored.

    """

    def __init__(self, base_img_path):
        # Load envirnoment vectorizer from .env in project root
        load_dotenv()

        # Parse config.yaml
        with open("config.yaml", 'r') as stream:
            try:
                config = load(stream, Loader)
            except YAMLError as error:
                logger.error("Error while opening config.yaml ", error)

        self.base_img_path = base_img_path

        self.postgres = Postgres()
        self.s3 = S3(base_img_path=self.base_img_path)
        self.detectron = Detectron(
            base_img_path=self.base_img_path,
            model_config=config["DETECTRON"]["MODEL_CONFIG"],
            threshold=config["DETECTRON"]["THRESHOLD"]
        )
        self.vectorizer = Vectorizer(
            base_img_path=self.base_img_path,
            model_name=config["VECTORIZER"]["MODEL"],
            input_dimensions=config["VECTORIZER"]["INPUT_DIMS"],
            batch_size=config["VECTORIZER"]["BATCH_SIZE"]
        )

    def process_image(self, arm_id, session_id, image_name):
        """
        This method runs object recognition on the passed image and saves the result to the database.

        Parameters
        ----------
        session_id : str
            Datetime based unique identifier of the current session. It is generated by the Raspberry Pi and passed
            with the POST request.
        image_name : str
            Name of the image to be processed. The image has to be uploaded to the s3 bucket. Value is passed
            with the POST request.

        """

        try:
            step = Path(image_name).stem

            # Create table in Postgres for current session if it does not exist yet
            self.postgres.create_table(schema_name=arm_id, table_name=session_id)

            # Create folders for original and cropped images if they do not exist
            Path(os.path.join(self.base_img_path, session_id, "original")).mkdir(parents=True, exist_ok=True)
            Path(os.path.join(self.base_img_path, session_id, "cropped")).mkdir(parents=True, exist_ok=True)

            # Download image if needed
            logger.info(f"Downloading image from AWS S3...", {"arm_id": arm_id, "session_id": session_id, "log_type": step})
            self.s3.download_image(session_id, image_name)

            # Run detectron to get bounding boxes
            logger.info(f"Image downloaded, predicting bounding boxes...", {"arm_id": arm_id, "session_id": session_id, "log_type": step})
            results = self.detectron.predict(session_id=session_id, image_name=image_name)

            # Insert bounding box locations to postgres
            logger.info(f"Bounding boxes predicted, saving results to Postgres...", {"arm_id": arm_id, "session_id": session_id, "log_type": step})
            self.postgres.insert_results(schema_name=arm_id, table_name=session_id, results=results)
            logger.info(f"Results saved to Postgres!", {"arm_id": arm_id, "session_id": session_id, "log_type": step})
        except Exception:
            traceback.print_exc()

    def vectorize_session_images(self, arm_constants, session_id):
        """
        This method is to be executed after the last image of a session is processed. It gets a list of unique
        images in the current session, retrieves all the objects that belong to each image and runs the vectorizer
        on them.

        Returns
        -------
        pairings : list
            List of dicts containing pairs of objects and clusters.
        session_id : str
            Datetime based unique identifier of the current session. It is generated by the Raspberry Pi and passed
            with the POST request.

        """

        # Get list of unique image names in current session
        unique_images = self.postgres.get_unique_images(schema_name=arm_constants["arm_id"], table_name=session_id)

        # Create separate lists of items and containers and convert them to absolute polar coordinates
        items = []
        conts = []
        for image_name in unique_images:
            for obj in self.postgres.get_objects_of_image(schema_name=arm_constants["arm_id"], table_name=session_id, image_name=image_name):
                (items if obj["class"] == 0 else conts).append(object_to_polar(arm_constants=arm_constants, image_name=image_name, obj=obj))

        # Filter out duplicates which are the same objects showing up on different images
        filtered_items = filter_duplicates(items)
        filtered_conts = filter_duplicates(conts)

        # Handle case if no containers were found
        n_containers = len(filtered_conts)
        if n_containers == 0:
            raise Exception("No containers were found!")

        # Run vectorizer to assign each object to a cluster
        pairings = self.vectorizer.run(session_id=session_id, unique_images=unique_images, objects=filtered_items, n_containers=n_containers)

        def pairing_matches_item(pairing, item):
            return pairing["image_id"] == item["img_base_angle"] and pairing["obj_id"] == item["obj_id"]

        commands = []
        for item in filtered_items:
            target_cont = next(filtered_conts[pairing["cluster"]] for pairing in pairings if pairing_matches_item(pairing, item))
            commands.append((item["avg_polar_coords"], target_cont["avg_polar_coords"],))

        return commands
